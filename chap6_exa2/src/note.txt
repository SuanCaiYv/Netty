1.首先,InboundHandler一般用来处理数据的读入;OutboundHandler一般用来处理数据的写出2.在InboundHandler中调用write()方法会把数据在OutboundHandler中写出,因为写操作属于出站操作,所以write()方法最后会在OutboundHandler的write()方法中发挥真正的"写"3.InboundHandler中的所有的write()都会把数据放到某一块中,在OutboundHandler中完成真正的"写"4.InboundHandler都是利用ChannelHandlerContext(全局管家)完成"写"的5.再强调一遍,InboundHandler主要完成"读"工作,"写"主要是OutboundHandler完成的,而OutboundHandler写的东西(原材料)是InboundHandler提供的6.若服务端写出的东西(OutboundHandler)是空的,那么服务端InboundHandler啥也不会收到7.In-Out不一定非得In-Out,可能是,In-In-In-Out,或是,In-Out-In-Out-In-Out,亦或是,In-Out-Out-Out-In,没必要是In,Out交替,和Selector那一套不同8.出站那一套都是写出数据,入站那一套都是读入数据9.入站处理器放在出站处理器前面,因为:在InboundHandler执行完成需要调用OutboundHandler的时候, 比如在InboundHandler调用ctx.writeAndFlush()方法, Netty是直接从该InboundHandler返回逆序的查找该InboundHandler之前的OutboundHandler, 并非从Pipeline的最后一项Handler开始查找。所以OutboundHandler一定要在最后一个InboundHandler之前10.InboundHandler和OutboundHandler中的IO操作都是由ChannelHandlerContext处理的,因为它是"全局管家",负责SocketChannel的IO操作11.OutboundHandler中的操作,大概除了write()都需要super中同名方法的支持